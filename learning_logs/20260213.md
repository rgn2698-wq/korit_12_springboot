# SpringBoot START

- SpringBoot 수업 시 vscode로 md파일 정리 / intellij로 자바 코드

- push 작업도 vscode 내에서 올린다. 그러니까 경로가 `C:\영어이름\korit_12_springboot` 라는 전제.

## Gradle
- 우리가 Java 초창기에 수업할때 Build System을 사용했던적이 있는데, 그떄 SpringBoot와의 연관성을 위해서 Gradle을 적용한다.
- Maven : mvn 검색할때 본적있다. 둘 다 Build System에 해당 되는데 Gradle이 좀 더 빠르고 유연하다.

Gradle의 구성(Config) 파일은 build.gradle에서 수행된다. 프로젝트의 요구 사항에 맞게 사용자가 지정 가능하며 프로젝트 컴파일에 필요한 외부 라이브러리 및 프레임워크 등 _프로젝트의 의존성_에 대한 정보를 포함한다. 그래서 어제 devtools / lombok / web / h2 와 같은 부분들을 build.gradle -> dependencies에 정의되어 있었다.

```java
plugins {
	id 'java'
	id 'org.springframework.boot' version '3.5.11-SNAPSHOT'
	id 'io.spring.dependency-management' version '1.1.7'
}

group = 'com.temp'
version = '0.0.1-SNAPSHOT'
description = 'Demo project for Spring Boot'

java {
	toolchain {
		languageVersion = JavaLanguageVersion.of(17)
	}
}

configurations {
	compileOnly {
		extendsFrom annotationProcessor
	}
}

repositories {
	mavenCentral()
	maven { url = 'https://repo.spring.io/snapshot' }
}

dependencies {
	implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
	implementation 'org.springframework.boot:spring-boot-starter-web'
	compileOnly 'org.projectlombok:lombok'
	developmentOnly 'org.springframework.boot:spring-boot-devtools'
	annotationProcessor 'org.projectlombok:lombok'

	runtimeOnly 'com.h2database:h2'

	testImplementation 'org.springframework.boot:spring-boot-starter-test'
	testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
}

tasks.named('test') {
	useJUnitPlatform()
}

```

### build.grale의 일반적인 파일 항목 목록
1. 플러그인(plugins) : 플러그인 블록은 프로젝트에 쓰이는 Gradle 플러그인을 정의하는곳으로 SpringBoot 버전을 정의한다.
2. 리포지토리(repositories) : 의존성을 해결하는데 쓰이는 의존성 리포지토리를 정의한다. 우리는 gradle이 의존성을 가지고 오기 위해 Maven Central 리포지토리를 이용했다.
3. 의존성(dependencies) : 프로젝트에서 이용되는 의존성을 지정한다.
4. 태스크(task) : 테스트 등의 빌드 프로세스의 일부를 정의한다.

# 스프링 이니셜라이저 활용 프로젝트 생성(Spring Initializr)

1. https://start.spring.io
2. 의존성
  - Spring Boot DecTools : 자동 재시작 기능을 제공하는 개발자 도구 포함 / 변경 내용을 저장 할때마다 애플리케이션이 자동으로 다시 시작된다.

  - Spring Boot Starter Web : 풀스택 개방을 위한 옵션으로 자체 내장 톰캣 서버를 제공한다. _옛날 스프링 시절에는 server 설정을 하나하나 다 잡아줘야 했다._

# main 단계에서의 springboot 프로젝트의 에너테이션


1. `@EnableAutoConfiguration` : 스프링부트의 자동 구성을 활성화한다. 프로젝트가 의존성에 따라 자동으로 구성 된다. _(추가 설정할 필요 X)_ 예를 들어서 spring-boot-starter-web 의존성이 있는 경우 스프링부트는 우리가 웹 애플리케이션을 개발중이라고 인식하고 그에 따라 애플리케이션 구성을 가진다.

2. `@ComponentScan` : 스프링부트 컴포넌트 검색으로, 애플리케이션의 모든 컴포넌트를 찾을수 있도록 한다.

3. `@Configration` : 빈(bean) 정의를 제공하는 소스로, 쓸수있는 클래스르 지정한다.

## 로그 및 문제 해결

1. Logging은 애플리케이션의 흐름을 모니터링 하는데 이용할 수 있고, 오류를 포착하는 방식이다. 스타터 패키지 내에 logback이 존재하는데 SLF4J(simple logging facade for Java)의 축약어다.

2. logger.info(); : 로그 메세지를 console에 출력한다
  - 로깅 수준 종류 : `TRACE / DEBUG / INFO / WARN / ERROR / FATAL / OFF` 수준이 있다.
  이를 `application,properties`에서 정의한다. 그래서 아까 `logging.level.root=DEBUG` 로 작성 했었는데, TRACE 버전의 경우 모든 세부 동작 정보를 더 추적하는 상태로, 가장 최상위 수준이다. *default 수준은 INFO.*

3. port number : 8080 (바꿔서 쓸수는 있지만 그대로 두도록하는걸로 함)
  - 실행중일때 또 실행버튼 눌러서 터지는 경우가 있다. 그래서 수업중에 애플리케이션 정지하라고 하면 미리 정지. _(안하면 application failed tro start 메세지가 찍힘. port 8080 was already in use. 라는 메세지도 같이 뜬다.)_ 몇번은 수정해주지만 일정시간 지나면 알아서 해결.

# 의존성 주입(Dependecy Injection : DI)
- 의존성 주입은 구성요소 간의 _느슨한 결합_ 을 이용하여 코드를 유연하고 유지 관리 및 테스트 하기 쉽게 만들어주는 요인이다.

## 의존성 주입 소개

- 의존성 주입은 `다른 객체에 의존하는 객체를 만들 수 있는 소프트웨어 개발 기법`으로, 클래스간의 상호작용을 도우면서 동시에 `클래스를 독립적으로 유지` 시킨다.


  - service : 클라이언트가 이용할수 있는 클래스(의존성) 을 의미 
    - h2database / lombok etc

  - client : 의존성을 이용하는 클래스
    - Logger를 CardatabaseApplication에서 이용했음.
  - Injector : 의존성을 의존클래스에 전달하는 기능 담당.

```java
public class Car{
  // field 선언
  private Owner owner;
  // 생성자 정의
  public Car() {
    owner = new Owner();
  }
}
```

이상의 코드는 클라이언트 클래스인 Car가 서비스클래스 인 Owner의 객체를 생성하기 때문에 의존성 주입이 없다.`(즉 직접 생성하기 때문에 요청과정이 없음.)`

```java
public class Car {
  private Owner owner;
  public Car(Owner owner) {
    this.owner = owner;
  }
}
```
서비스 객체(owner)가 클라이언트 클래스(Car)에서 직접 생성 되지않고, 매개변수로 전달된다.`(즉 CarMain 같은곳에서 owner 객체를 생성해서 집어넣어 줘야만 한다.)`

- 서비스 클래스는 추상 클래스 일수도있는데, 이 경우 클라이언트 클래스에서 해당 클래스의 어떤 구현이든 이용할수 있고, 테스트 중에서는 모형(Mock)을 이용 할 수도 있다.

- 의존성 주입방속도 여러가지가 있다.

  1. 생성자 주입(Constructor Injection) :
  의존성이 클라이언트 클래스 새성자에 전달 되는 방식, 방금 위에 방식에 해당한다. 생성자 주입은 필수 의존성에 이용하는것이 좋다.

  2. 세터 주입(Setter Injection) : 의존성이 세터를 통해 제공되는 방식이다. 예시는 이하와 같다.

```java
public class Car {
  private Owner owner;
  public void setOwner(Owner owner) {
    this.owner = owner;
  }
}

public class CarMain {
  public static void main (String[] args) {
    Car car1 = new Car();
    Car car2 = new Car();

    Owner owner1 = new Owner();
    car1.setOwner(owner1);
    car2.setOwner(owner1);
  }
}
```
즉 이상의 코드의 세터 주입은 의존성이 없더라도 일단 객체를 기본 생성자로 만들수 있기 때문에 더 유연하다. 생성자 주입의 경우 AllArgsConstructor이기 떄문에 일단 Owner가 만들어 져야 Car 객체를 만들수 있다.

즉, 의존성 주입은 코드 자체의 의존성을 줄이고, 코드를 재사용 하기 쉽게 `(Car1에도 Car2에도 onwer1을 쓴다는점)` 테스트를 할수 있도록 해준다.

## SpringBoot에서의 의존성 주입 이용

- 스프링 프레임워크에서 의존성 주입은 `ApplicationContext`를 통해서 이루어진다. 이는 객체(bean)와 객체의 의존성을 생성하고 관리하는 역할을 한다.

- 스프링부트는 애플리케이션 클래스를 검색하여 특정 애너테이션(`@Service`,`@Repository`, `@Controller` 등)이 있는 클래스를 빈으로 등록한다. `(의존성 주입을 통해 빈을 주입하는게 가능함.)`

- 일반적인 방법은 일단 이상에서 배웠던 `생성자 주입`

- 객체가 생성될때 필요한 모든 의존성을 반드시 이용하게 하므로`(AllArgsConstructor니까 빠지면 객체 생성에 실패)` 가장 권장되는 방식이다. 가장 보편적인 상황은 특정 작업을 위해 데이터베이스에 대한 접근이 필요한 경우다. 스프링부트에서는 DB에 접근하는 클래스를 `리포지토리` 클래스라고 한다. 이하의 예시를 확인하면

```java
public class Car {
  private final CarRepository carRepository;

  public Car(CarRepository carRepository) {
    this.carRepository = carRepository;
  }

  carRepository.findAll();
  // findAll() : 저장된 DB를 불러온다.
}
```
그런데 클래스 생성자가 여러 개 있는 경우에는 `@Autowired` 애너테이션을 이용하여 의존성 주입에 이용되는 생성자를 정의해야 된다.

`세터 주입` : 선택적 의존성인 경우나, 프로그램 실행중에 의존성 수정하는 경우에 사용한다.

```java
@Service
public class AppUserService {
  private AppUserRepository AppUserRepository;

  @Autowired
  public void setAppUserRepository(AppUserRepository userRepository) {
    this.userRepository = userRepository;
  }
}
```

`필드 주입` : 의존성을 필드에 직접 주입. 단순하지만 오류가 발생할 가능성이 높다. 그리고 테스트용의 객체를 별개로 생성할수가 없어서 테스트 하기도 까다롭다.

```java
@Service
public class CarDatabaseService implements CarService {
  // CarDatabaseService 인터페이스가 구현 되어있다고 가정
}
public class CarController {
  @Autowired
  private CarDatabaseService CarDatabaseService;
}
```
이상의 코드가 가장 혼란스러울수 있는데, 그냥

```java
public class CarController {
  pirvate CarDatabaseService carDatabaseService = new CarDatabaseService();
}
```
와 같다고 보면 된다.

